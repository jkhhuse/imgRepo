## 前情概要
使用过Angular表单，那么对于*响应式表单*这个并不模式，响应式表单是围绕数据模型的操控，在响应式表单中，`FormControl`一个表单的最小单元控件，它可以控制控件的值及状态，它对应于HTML表单控件，例如`input`、`textarea`。

例如在响应式表单下创建一个表单可以使用下面方式：
```angular
------template-------
<label>
  Content: 
  <textarea type="text" [formControl]="content"></textarea>
</label>
------component-------
content = new FormControl('jack');
```

但是上述的例子是建立在我们使用HTML原生的控件基础之上的，在实际应用中，如果遇到在原生控件中添加一些额外的行为/属性/样式的情况下，定义一个表单也会变得复杂很多。

Angular中应对以上情况，提供了一个自定义操控表单的API：`ControlValueAccessor`，Angular给了它一个定义：

> A ControlValueAccessor acts as a bridge between the Angular forms API and a native element in the DOM.

`ControlValueAccessor`是连接Angular Form API 与原生DOM元素的桥梁，先看一下`ControlValueAccessor`有哪些方法：

```ts
interface ControlValueAccessor {
  writeValue(obj: any): void
  registerOnChange(fn: any): void
  registerOnTouched(fn: any): void
  setDisabledState(isDisabled: boolean)?: void
}
```

`writeValue`负责从Form模型中把数据写入到UI视图中（model->view），用法如下：

```ts
writeValue(value: any): void {
  this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
}
```

`registreOnChange()`原生UI视图值更新时被触发的回调函数，
它在Form API 初始化时被调用，当UI视图中值变化的同时更新模型中的值，即（view->model）。可以

`setDisabledState()`当`control.disabled`状态改变时时被调用，它会同步改变DOM元素的状态为`disable`或者`enable`，它的用法为：

```ts
setDisabledState(isDisabled: boolean): void {
  this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
}
```